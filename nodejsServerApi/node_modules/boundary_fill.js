class MapPoint {
    constructor(latitude, longitude) {
        this.latitude = latitude;
        this.longitude = longitude;
    }

    "-"(a, b) {
        return new MapPoint(a.latitude - b.latitude, a.longitude - b.longitude);
    }
}

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

class Field {
    constructor(owner, isTail) {
        this.owner = owner;
        this.isTail = isTail;
    }
}

class Player {
    constructor(name, id, ws, arena, color, x = -1, y = -1) {
        this.name = name;
        this.id = id;
        this.ws = ws;
        this.gridPosition = new Point(x, y);
        this.arena = arena
        this.activTail = []; // array of point objects
        this.color = color;
    }

    isOutOfArenaGrid(gridCoords) {
        return new Promise(resolve => {
            var out = (
                gridCoords.x == -1 ||
                gridCoords.x >= this.arena.gridSize.x ||
                gridCoords.y >= this.arena.gridSize.y
            )
            resolve(out);
        });
    }

    cutTail() {
        console.log("cutTail is not implemented yet");
    }

    outOfArena() {
        console.log("outOfArena is not implemented yet");
    }

    fillArea() {
        console.log("fillArea is not fully implemented yet")
        // find the boundary box of our area
        // fill this area
        // the leftout are is what is additional area
        while (this.activTail.length != 0) {
            cur = this.activTail[this.activTail.length - 1];
            this.activTail.pop();
            if (this.isOutOfArenaGrid(cur)) continue;
            if (this.arena.owner[cur.x][cur.y] == this.id) {
                this.arena.setAsOwner(cur, this);
                if (this.arena.owner[cur.x][cur.y].isTail) {

                }
            }
        }

    }

    addToTail(gridCoords) {
        this.activTail.push(gridCoords);
        this.arena.setAsTail(gridCoords, this);
    }

    async updatePosition(newLocation) {
        var gridCoords = await this.arena.convertToArenaGrid(newLocation);
        this.gridPosition = gridCoords;
        if (await this.isOutOfArenaGrid(gridCoords) === true) {
            // out of arena
            this.outOfArena();
        }
        else {
            // is on own territory
            if (this.arena.fields[gridCoords.x][gridCoords.y].owner == this.id) {
                if (!this.arena.fields[gridCoords.x][gridCoords.y].isTail) {
                    // has a tail
                    if (this.activTail.length != 0) {
                        this.fillArea();
                        this.activTail = [];
                    }
                }
            }
            else {
                this.addToTail(gridCoords);
            }
        }
    }

    // This is a very bruteforce method
    async removeSelf() {
        for (var i = 0; i < this.arena.gridSize.x; i++) {
            for (var j = 0; j < this.arena.gridSize.y; j++) {
                var owner = await this.arena.ownerOf(new Point(i, j));
                if (owner == this.id) {
                    this.arena.setAsEmpty(new Point(i, j));
                }
            }
        }
    }
}


class Arena {
    constructor(name, upperLeftCorner, lowerRightCorner, latitudeGridUnitCount) {
        this.players = new Map(); // playerid player map
        this.name = name;
        this.fields = [];
        this.upperLeftCorner = upperLeftCorner;
        this.lowerRightCorner = lowerRightCorner;
        this.sizeOnMap = new MapPoint(
            Math.abs(lowerRightCorner.latitude - upperLeftCorner.latitude),
            Math.abs(lowerRightCorner.longitude - upperLeftCorner.longitude));
        // because we want square units it's enough to have the count of units on only 1 axis
        // size of 1 grid unit in latitude and longitude
        // this may cause problems later, but I view latitude and longitue directly proportional
        this.gridSize = {
            x: latitudeGridUnitCount,
            y: Math.floor(this.sizeOnMap.longitude / this.sizeOnMap.latitude * latitudeGridUnitCount)
        };
        console.log(`This is the gridsize`);
        console.log(this.gridSize);
        this.gridUnitSize = this.sizeOnMap.latitude / this.gridSize.x;


        for (var i = 0; i < this.gridSize.x; i++) {
            var l = [];
            for (var j = 0; j < this.gridSize.y; j++) {
                l.push(new Field("none", false));
            }
            this.fields.push(l);
        }
    }

    convertToArenaGrid(pointOnMap) {
        return new Promise(resolve => {
            if (pointOnMap.latitude > this.upperLeftCorner.latitude ||
                pointOnMap.latitude < this.lowerRightCorner.latitude ||
                pointOnMap.longitude < this.upperLeftCorner.longitude ||
                pointOnMap.longitude > this.lowerRightCorner.longitude) {

                // if it is outside the arena
                resolve(new Point(-1, -1));
            }
            else {
                var dif = new MapPoint(
                    this.upperLeftCorner.latitude - pointOnMap.latitude,
                    pointOnMap.longitude - this.upperLeftCorner.longitude);
                resolve(new Point(
                    Math.floor(dif.latitude / this.gridUnitSize),
                    Math.floor(dif.longitude / this.gridUnitSize)
                ));
            }
        });
    }

    // you could implement a more optimised version which only sends the changes but that's for later
    sendDataToPlayers() {
        var array = JSON.stringify(this.fields)
        var toSend = {
            type: "arenaData",
            arenaData: array,
            upperLeftCornerLatitude: this.upperLeftCorner.latitude,
            upperLeftCornerLongitude: this.upperLeftCorner.longitude,
            gridUnitSize: this.gridUnitSize
        }
        toSend = JSON.stringify(toSend);
        for (let [id, player] of this.players) {
            player.ws.send(toSend);
        }
    }

    addPlayer(name, id, ws, color, x = -1, y = -1) {
        console.log(`Player with name ${name} and id ${id} is added to the arena`);
        this.players.set(id, new Player(name, id, ws, this, color, x, y));
    }

    async removePlayer(id) {
        if (this.players.has(id)) {
            console.log(`Removing player with id ${id}`);
            await this.players.get(id).removeSelf();
            this.players.delete(id);
        }
    }

    async updatePosition(playerID, newLocation) {
        var player = await this.players.get(playerID);
        player.updatePosition(newLocation);
    }

    isOnGrid(gridCoords) {
        return new Promise(resolve => {
            resolve(0 <= gridCoords.x && gridCoords.x < this.gridSize.x &&
                0 <= gridCoords.y && gridCoords.y < this.gridSize.y);
        });
    }


    setAsTail(gridCoords, player) {
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].owner != player.id) {
                if (this.fields[gridCoords.x][gridCoords.y].isTail) {
                    previousPlayerID = this.fields[gridCoords.x][gridCoords.y];
                    previousPlayer = players[previousPlayerID];
                    previousPlayer.cutTail();
                }

                this.fields[gridCoords.x][gridCoords.y].owner = player.id;
                this.fields[gridCoords.x][gridCoords.y].isTail = true;
            }
        }
    }

    setAsOwner(gridCoords, player) {
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].owner != player.id) {
                if (this.fields[gridCoords.x][gridCoords.y].isTail) {
                    previousPlayerID = this.fields[gridCoords.x][gridCoords.y];
                    previousPlayer = players[previousPlayerID];
                    previousPlayer.cutTail();
                }

                this.fields[gridCoords.x][gridCoords.y].owner = player.id;
                this.fields[gridCoords.x][gridCoords.y].isTail = false;
            }
        }
    }

    setAsEmpty(gridCoords) {
        if (this.isOnGrid(gridCoords)) {
            this.fields[gridCoords.x][gridCoords.y].owner = "none";
            this.fields[gridCoords.x][gridCoords.y].isTail = false;
        }
    }

    ownerOf(gridCoords) {
        return new Promise(resolve => {
            if (this.isOnGrid(gridCoords)) {
                resolve(this.fields[gridCoords.x][gridCoords.y].owner);
            }
            resolve(-1);
        });
    }
}


module.exports = {
    Arena, Player, Point, MapPoint
}