class MapPoint {
    constructor(latitude, longitude) {
        this.latitude = latitude;
        this.longitude = longitude;
    }

    "-"(a, b) {
        return new MapPoint(a.latitude - b.latitude, a.longitude - b.longitude);
    }
}

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    manhattanDistance(other) {
        return new Promise(resolve => {
            resolve(Math.abs(this.x - other.x) + Math.abs(this.y - other.y));
        });
    }
}

class Field {
    constructor(owner = "none", tailOwner = "none") {
        this.owner = owner;
        this.tailOwner = tailOwner;
    }
}

class Player {
    constructor(name, id, ws, arena, color, lastknownChange, x = -1, y = -1) {
        this.name = name;
        this.id = id;
        this.ws = ws;
        this.gridPosition = new Point(x, y);
        this.arena = arena;
        this.activTail = []; // array of point objects
        this.color = color;
        this.position = new MapPoint(-1, -1);
        this.hasBase = false;
        this.lastKnownChange = lastknownChange;
        this.upperLeft = new Point(1000000000, 1000000000);
        this.lowerRight = new Point(0, 0);
    }

    isOutOfArenaGrid(gridCoords) {
        return new Promise(resolve => {
            var out = (
                gridCoords.x < 0 || gridCoords.y < 0 ||
                gridCoords.x >= this.arena.gridSize.x ||
                gridCoords.y >= this.arena.gridSize.y
            )
            resolve(out);
        });
    }

    cutTail() {
        console.log("cutTail is not implemented yet");
    }

    outOfArena() {
        console.log("outOfArena is not implemented yet");
    }

    async fillArea() {
        // find the boundary box of our area
        // fill this area
        // the leftout are is what is additional area
        let curr;

        if (this.activTail.length == 0) {
            return;
        }

        for (let i = 0; i < this.activTail.length; i++) {
            this.upperLeft.x = Math.min(this.upperLeft.x, this.activTail[i].x);
            this.upperLeft.y = Math.min(this.upperLeft.y, this.activTail[i].y);
            this.lowerRight.x = Math.max(this.lowerRight.x, this.activTail[i].x);
            this.lowerRight.y = Math.max(this.lowerRight.y, this.activTail[i].y);
        }

        let stack = [];
        for (let i = this.upperLeft.x; i <= this.lowerRight.x; i++) {
            stack.push(new Point(i, this.upperLeft.y));
            stack.push(new Point(i, this.lowerRight.y));
        }
        for (let i = this.upperLeft.y; i <= this.lowerRight.y; i++) {
            stack.push(new Point(this.upperLeft.x, i));
            stack.push(new Point(this.lowerRight.x, i));
        }

        let visited = [];
        for (let i = this.upperLeft.x; i <= this.lowerRight.x; i++) {
            let temp = [];
            for (let j = this.upperLeft.y; j <= this.lowerRight.y; j++) {
                temp.push(false);
            }
            visited.push(temp);
        }

        let dirX = [0, 0, 1, -1];
        let dirY = [1, -1, 0, 0];

        while (stack.length > 0) {
            curr = stack[stack.length - 1];
            stack.pop();
            if (curr.x < this.upperLeft.x || curr.y < this.upperLeft.y || curr.x > this.lowerRight.x || curr.y > this.lowerRight.y) continue;

            if (visited[curr.x - this.upperLeft.x][curr.y - this.upperLeft.y] == true) continue;
            let owner = await this.arena.ownerOf(curr);
            if (owner == this.id) continue;
            owner = await this.arena.tailerOf(curr);
            if (owner == this.id) continue;

            visited[curr.x - this.upperLeft.x][curr.y - this.upperLeft.y] = true;
            for (let i = 0; i < 4; i++) {
                stack.push(new Point(curr.x + dirX[i], curr.y + dirY[i]));
            }
        }

        for (let i = this.upperLeft.x; i <= this.lowerRight.x; i++) {
            for (let j = this.upperLeft.y; j <= this.lowerRight.y; j++) {
                if (visited[i - this.upperLeft.x][j - this.upperLeft.y] === false) {
                    this.arena.setAsOwner(new Point(i, j), this);
                }
            }
        }

        this.activTail = [];
    }

    async addToTail(gridCoords) {
        this.activTail.push(gridCoords);
        this.arena.setAsTail(gridCoords, this);
    }

    // credit: https://www.redblobgames.com/grids/line-drawing.html
    async fillBetween(prevPos, currPos) {
        if (currPos.x == prevPos.x && currPos.y == prevPos.y) return;
        let dx = currPos.x - prevPos.x, dy = currPos.y - prevPos.y;
        let nx = Math.abs(dx), ny = Math.abs(dy);
        let sign_x = dx > 0 ? 1 : -1, sign_y = dy > 0 ? 1 : -1;

        let p = new Point(prevPos.x, prevPos.y);
        for (let ix = 0, iy = 0; ix < nx || iy < ny;) {
            if ((0.5 + ix) / nx < (0.5 + iy) / ny) {
                // next step is horizontal
                p.x += sign_x;
                ix++;
            } else {
                // next step is vertical
                p.y += sign_y;
                iy++;
            }
            await this.processPosition(new Point(p.x, p.y));
        }
    }

    async processPosition(gridCoords) {
        // is on own territory

        let owner = await this.arena.ownerOf(gridCoords);
        if (owner == this.id) {
            await this.fillArea();
        }
        else {
            await this.addToTail(gridCoords);
        }
    }

    async updatePosition(newLocation) {
        this.position.latitude = newLocation.latitude;
        this.position.longitude = newLocation.longitude;
        let gridCoords = await this.arena.convertToArenaGrid(newLocation);
        // out of arena
        if (await this.isOutOfArenaGrid(gridCoords) === true) {
            this.outOfArena();
        }
        else {
            let prevPos = this.gridPosition;
            this.gridPosition = gridCoords;
            let currPos = this.gridPosition;
            if (this.hasBase === false) {
                this.arena.setAsOwner(this.gridPosition, this);
                this.hasBase = true;
                this.upperLeftCorner = new Point(this.gridPosition.x, this.gridPosition.y);
                this.lowerRightCorner = new Point(this.gridPosition.x, this.gridPosition.y);
                return;
            }
            this.fillBetween(prevPos, currPos);
        }
    }

    // This is a very bruteforce method
    async removeSelf() {
        for (var i = 0; i < this.arena.gridSize.x; i++) {
            for (var j = 0; j < this.arena.gridSize.y; j++) {
                var owner = await this.arena.ownerOf(new Point(i, j));
                if (owner == this.id) {
                    this.arena.setAsEmpty(new Point(i, j));
                }
                var tailer = await this.arena.tailerOf(new Point(i, j));
                if (tailer == this.id) {
                    this.arena.setTailEmpty(new Point(i, j));
                }
            }
        }
    }
}

// küldött event tipusok
// 1 a b c : az a b hely a c jatekose lett (a b -1 azt jelenti, hogy ures lett)
// 2 a b c : az a b helyen a c jatekos csikot huz (a b -1 azt jelenti, hogy ures lett a csik)
class Change {
    constructor(type, a, b, c) {
        this.type = type;
        this.a = a;
        this.b = b;
        this.c = c;
        this.count = -1;
    }

    toSend() {
        return new Promise(resolve => {
            resolve({
                type: this.type,
                a: this.a,
                b: this.b,
                c: this.c,
                count: this.count
            });
        });
    }
}

class Arena {
    constructor(_name, _upperLeftCorner, _lowerRightCorner, _latitudeGridUnitCount) {
        this.players = new Map(); // playerid player map
        this.name = _name;
        this.fields = [];
        this.upperLeftCorner = new MapPoint(_upperLeftCorner.latitude, _upperLeftCorner.longitude);
        this.lowerRightCorner = new MapPoint(_lowerRightCorner.latitude, _lowerRightCorner.longitude);
        console.log("name ", _name);
        console.log(this.upperLeftCorner);
        this.sizeOnMap = new MapPoint(
            Math.abs(_lowerRightCorner.latitude - _upperLeftCorner.latitude),
            Math.abs(_lowerRightCorner.longitude - _upperLeftCorner.longitude));
        // because we want square units it's enough to have the count of units on only 1 axis
        // size of 1 grid unit in latitude and longitude
        // this may cause problems later, but I view latitude and longitue directly proportional
        this.gridSize = {
            x: _latitudeGridUnitCount,
            y: Math.floor(this.sizeOnMap.longitude / this.sizeOnMap.latitude * _latitudeGridUnitCount)
        };
        console.log(`This is the gridsize`);
        console.log(this.gridSize);
        this.gridUnitSize = this.sizeOnMap.latitude / this.gridSize.x;
        console.log("gridUnitSize ", this.gridUnitSize);

        for (var i = 0; i < this.gridSize.x; i++) {
            var l = [];
            for (var j = 0; j < this.gridSize.y; j++) {
                l.push(new Field());
            }
            this.fields.push(l);
        }

        this.changeLog = [];

        setInterval(() => { this.sendDataToPlayers(); }, 1000);
    }

    convertToArenaGrid(pointOnMap) {
        return new Promise(resolve => {
            if (pointOnMap.latitude > this.upperLeftCorner.latitude ||
                pointOnMap.latitude < this.lowerRightCorner.latitude ||
                pointOnMap.longitude < this.upperLeftCorner.longitude ||
                pointOnMap.longitude > this.lowerRightCorner.longitude) {

                // if it is outside the arena
                resolve(new Point(-1, -1));
            }
            else {
                var dif = new MapPoint(
                    this.upperLeftCorner.latitude - pointOnMap.latitude,
                    pointOnMap.longitude - this.upperLeftCorner.longitude);
                resolve(new Point(
                    Math.floor(dif.latitude / this.gridUnitSize),
                    Math.floor(dif.longitude / this.gridUnitSize)
                ));
            }
        });
    }

    changeLastKnown(playerId, lastKnown) {
        this.players.get(playerId).lastKnownChange = lastKnown;
    }

    // you could implement a more optimised version which only sends the changes but that's for later
    async sendDataToPlayers() {
        /*
        var playerPositions = [];
        for (let [id, player] of this.players) {
            playerPositions.push(JSON.stringify({
                id: id,
                latitude: player.position.latitude,
                longitude: player.position.longitude
            }));
        }
        playerPositions = JSON.stringify(playerPositions);
        */

        for (let [id, player] of this.players) {
            if (player.lastKnownChange == this.changeLog.length - 1) continue;
            this.getToSend(player).then(function (toSend) {
                toSend = JSON.stringify(toSend);
                player.ws.send(toSend);
            }, function (reason) {
                console.log("Promise rejected", reason);
            });
        }
    }

    getToSend(player) {
        return new Promise(resolve => {
            let changeLogSlice = this.changeLog.slice(player.lastKnownChange + 1);
            let toSend = {
                type: "changeLogUpdate",
                newChanges: changeLogSlice,
                newLastKnown: this.changeLog.length - 1
            };
            resolve(toSend);
        });
    }

    sendBeginningData(player) {
        var array = JSON.stringify(this.fields);

        let toSend = {
            type: "beginningData",
            arenaData: array,
            ownId: player.id,
            lastKnownChange: player.lastKnownChange,
            upperLeftCornerLatitude: this.upperLeftCorner.latitude,
            upperLeftCornerLongitude: this.upperLeftCorner.longitude,
            lowerRightCornerLatitude: this.lowerRightCorner.latitude,
            lowerRightCornerLongitude: this.lowerRightCorner.longitude,
            gridUnitSize: this.gridUnitSize,
        }
        toSend = JSON.stringify(toSend);
        player.ws.send(toSend);
    }

    addPlayer(name, id, ws, color, x = -1, y = -1) {
        console.log(`Player with name ${name} and id ${id} is added to arena ${this.name}`);
        let newPlayer = new Player(name, id, ws, this, color, -1, x, y)
        this.players.set(id, newPlayer);
        this.sendBeginningData(newPlayer);
    }

    async removePlayer(id) {
        if (this.players.has(id)) {
            console.log(`Removing player with id ${id}`);
            await this.players.get(id).removeSelf();
            this.players.delete(id);
        }
    }

    async updatePosition(playerID, newLocation) {
        var player = await this.players.get(playerID);
        if (player == undefined) return;
        player.updatePosition(newLocation);
    }

    async isOnGrid(gridCoords) {
        return new Promise(resolve => {
            resolve(0 <= gridCoords.x && gridCoords.x < this.gridSize.x &&
                0 <= gridCoords.y && gridCoords.y < this.gridSize.y);
        });
    }

    addToChangeLog(change) {
        change.count = this.changeLog.length;
        this.changeLog.push(change);
    }

    setAsTail(gridCoords, player) {
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].owner != player.id && this.fields[gridCoords.x][gridCoords.y].tailOwner != player.id) {
                if (this.fields[gridCoords.x][gridCoords.y].tailOwner != "none") {
                    let previousPlayerID = this.fields[gridCoords.x][gridCoords.y];
                    let previousPlayer = this.players[previousPlayerID];
                    if (previousPlayer != undefined) {
                        previousPlayer.cutTail();
                    }
                }
                this.tailerOf(gridCoords.x, gridCoords.y).then((ret) => {
                    if (ret == player.id) return;
                    this.addToChangeLog(new Change(2, gridCoords.x, gridCoords.y, player.id));
                    this.fields[gridCoords.x][gridCoords.y].tailOwner = player.id;
                });
            }
        }
    }

    setAsOwner(gridCoords, player) {
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].tailOwner != "none") {
                let previousPlayerID = this.fields[gridCoords.x][gridCoords.y].tailOwner;
                let previousPlayer = this.players[previousPlayerID];
                if (previousPlayer != undefined) {
                    previousPlayer.cutTail();
                }
            }
            this.ownerOf(gridCoords.x, gridCoords.y).then((ret) => {
                if (ret == player.id) return;
                this.addToChangeLog(new Change(1, gridCoords.x, gridCoords.y, player.id));
                this.addToChangeLog(new Change(2, gridCoords.x, gridCoords.y, -1));
                this.fields[gridCoords.x][gridCoords.y].owner = player.id;
                this.fields[gridCoords.x][gridCoords.y].tailOwner = "none";
            });
        }
    }

    setAsEmpty(gridCoords) {
        this.setTailEmpty(gridCoords);
        this.setOwnerEmpty(gridCoords);
    }

    setTailEmpty(gridCoords) {
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].tailOwner != "none") {
                this.fields[gridCoords.x][gridCoords.y].tailOwner = "none";
                this.addToChangeLog(new Change(2, gridCoords.x, gridCoords.y, -1));
            }
        }
    }

    setOwnerEmpty(gridCoords) {
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].owner != "none") {
                this.fields[gridCoords.x][gridCoords.y].owner = "none";
                this.addToChangeLog(new Change(1, gridCoords.x, gridCoords.y, -1));
            }
        }
    }

    async ownerOf(gridCoords) {
        return new Promise(resolve => {
            this.isOnGrid(gridCoords).then((value) => {
                if (value) {
                    resolve(this.fields[gridCoords.x][gridCoords.y].owner);
                }
                else {
                    resolve(-1);
                }
            });

        });
    }

    async tailerOf(gridCoords) {
        return new Promise(resolve => {
            this.isOnGrid(gridCoords).then((value) => {
                if (value) {
                    resolve(this.fields[gridCoords.x][gridCoords.y].tailOwner);
                }
                else {
                    resolve(-1);
                }
            });
        });
    }
}


module.exports = {
    Arena, Player, Point, MapPoint
}