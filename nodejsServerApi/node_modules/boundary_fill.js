class MapPoint {
    constructor(latitude, longitude) {
        this.latitude = latitude;
        this.longitude = longitude;
    }

    "-"(a, b) {
        return new MapPoint(a.latitude - b.latitude, a.longitude - b.longitude);
    }
}

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

class Field {
    constructor(owner, isTail) {
        this.owner = owner;
        this.isTail = isTail;
    }
}

class Player {
    constructor(name, id, ws, arena, color, x = -1, y = -1) {
        this.name = name;
        this.id = id;
        this.ws = ws;
        this.gridPosition = new Point(x, y);
        this.arena = arena
        this.activTail = []; // array of point objects
        this.color = color;
        this.position = new MapPoint(-1, -1);
        this.hasBase = false;
    }

    isOutOfArenaGrid(gridCoords) {
        return new Promise(resolve => {
            var out = (
                gridCoords.x == -1 ||
                gridCoords.x >= this.arena.gridSize.x ||
                gridCoords.y >= this.arena.gridSize.y
            )
            resolve(out);
        });
    }

    cutTail() {
        console.log("cutTail is not implemented yet");
    }

    outOfArena() {
        console.log("outOfArena is not implemented yet");
    }

    fillArea() {
        console.log("fillArea is not fully implemented yet")
        // find the boundary box of our area
        // fill this area
        // the leftout are is what is additional area
        while (this.activTail.length != 0) {
            cur = this.activTail[this.activTail.length - 1];
            this.activTail.pop();
            if (this.isOutOfArenaGrid(cur)) continue;
            if (this.arena.owner[cur.x][cur.y] == this.id) {
                this.arena.setAsOwner(cur, this);
                if (this.arena.owner[cur.x][cur.y].isTail) {

                }
            }
        }

        let stack = [];
        for (let i = 0; i < this.arena.gridSize.x; i++) {
            stack.add(new Point(i, 0));
            stack.add(new Point(i, this.arena.gridSize.y - 1));
        }
        for (let i = 0; i < this.arena.gridSize.y; i++) {
            stack.add(new Point(0, i));
            stack.add(new Point(this.arena.gridSize.x, i));
        }

        let visited = [];
        for (let i = 0; i < this.arena.gridSize.x; i++) {
            let temp = [];
            for (let j = 0; j < this.arena.gridSize.y; j++) {
                temp.push(false);
            }
            visited.push(temp);
        }

        let dirX = [0, 0, 1, -1];
        let dirY = [0, 0, 1, -1];

        let curr;
        while (stack.length > 0) {
            curr = stack[stack.length - 1];
            stack.pop();
            if (curr.x < 0 || curr.y < 0
                || curr.x >= this.arena.gridSize.x
                || curr.y >= this.arena.gridSize.y) continue;

            if (visited[curr.x][curr.y] === true) continue;
            if (this.arena.ownerOf(curr) === this.id) continue;

            visited[curr.x][curr.y] = true;
            for (let i = 0; i < 4; i++) {
                stack.push(new Point(curr.x + dirX[i], curr.y + dirY[i]));
            }
        }

        for (let i = 0; i < this.arena.gridSize.x; i++) {
            for (let j = 0; j < this.arena.gridSize.y; j++) {
                if (!visited[i][j]) {
                    this.arena.setAsOwner(new Point(i, j), this);
                }
            }
        }
    }

    addToTail(gridCoords) {
        this.activTail.push(gridCoords);
        this.arena.setAsTail(gridCoords, this);
    }

    async updatePosition(newLocation) {
        this.position.latitude = newLocation.latitude;
        this.position.longitude = newLocation.longitude;
        var gridCoords = await this.arena.convertToArenaGrid(newLocation);
        this.gridPosition = gridCoords;
        // out of arena
        if (await this.isOutOfArenaGrid(gridCoords) === true) {
            this.outOfArena();
        }
        else {
            if (this.hasBase === false) {
                this.arena.setAsOwner(this.gridPosition, this);
                this.hasBase = true;
            }

            // is on own territory
            if (this.arena.fields[gridCoords.x][gridCoords.y].owner == this.id) {
                // has a tail
                if (!this.arena.fields[gridCoords.x][gridCoords.y].isTail) {
                    if (this.activTail.length != 0) {
                        this.fillArea();
                        this.activTail = [];
                    }
                }
            }
            else {
                this.addToTail(gridCoords);
            }
        }
    }

    // This is a very bruteforce method
    async removeSelf() {
        for (var i = 0; i < this.arena.gridSize.x; i++) {
            for (var j = 0; j < this.arena.gridSize.y; j++) {
                var owner = await this.arena.ownerOf(new Point(i, j));
                if (owner == this.id) {
                    this.arena.setAsEmpty(new Point(i, j));
                }
            }
        }
    }
}


class Arena {
    constructor(_name, _upperLeftCorner, _lowerRightCorner, _latitudeGridUnitCount) {
        this.players = new Map(); // playerid player map
        this.name = _name;
        this.fields = [];
        this.upperLeftCorner = new MapPoint(_upperLeftCorner.latitude, _upperLeftCorner.longitude);
        this.lowerRightCorner = new MapPoint(_lowerRightCorner.latitude, _lowerRightCorner.longitude);
        console.log("name ", _name);
        console.log(this.upperLeftCorner);
        this.sizeOnMap = new MapPoint(
            Math.abs(_lowerRightCorner.latitude - _upperLeftCorner.latitude),
            Math.abs(_lowerRightCorner.longitude - _upperLeftCorner.longitude));
        // because we want square units it's enough to have the count of units on only 1 axis
        // size of 1 grid unit in latitude and longitude
        // this may cause problems later, but I view latitude and longitue directly proportional
        this.gridSize = {
            x: _latitudeGridUnitCount,
            y: Math.floor(this.sizeOnMap.longitude / this.sizeOnMap.latitude * _latitudeGridUnitCount)
        };
        console.log(`This is the gridsize`);
        console.log(this.gridSize);
        this.gridUnitSize = this.sizeOnMap.latitude / this.gridSize.x;


        for (var i = 0; i < this.gridSize.x; i++) {
            var l = [];
            for (var j = 0; j < this.gridSize.y; j++) {
                l.push(new Field("none", false));
            }
            this.fields.push(l);
        }

        setInterval(() => { this.sendDataToPlayers(); }, 2000);
    }

    convertToArenaGrid(pointOnMap) {
        return new Promise(resolve => {
            if (pointOnMap.latitude > this.upperLeftCorner.latitude ||
                pointOnMap.latitude < this.lowerRightCorner.latitude ||
                pointOnMap.longitude < this.upperLeftCorner.longitude ||
                pointOnMap.longitude > this.lowerRightCorner.longitude) {

                // if it is outside the arena
                resolve(new Point(-1, -1));
            }
            else {
                var dif = new MapPoint(
                    this.upperLeftCorner.latitude - pointOnMap.latitude,
                    pointOnMap.longitude - this.upperLeftCorner.longitude);
                resolve(new Point(
                    Math.floor(dif.latitude / this.gridUnitSize),
                    Math.floor(dif.longitude / this.gridUnitSize)
                ));
            }
        });
    }

    // you could implement a more optimised version which only sends the changes but that's for later
    async sendDataToPlayers() {
        var array = JSON.stringify(this.fields);
        if (this.upperLeftCorner === undefined) return;
        var playerPositions = [];

        for (let [id, player] of this.players) {
            playerPositions.push(JSON.stringify({
                id: id,
                latitude: player.position.latitude,
                longitude: player.position.longitude
            }));
        }
        playerPositions = JSON.stringify(playerPositions);


        for (let [id, player] of this.players) {
            let toSend = {
                type: "arenaData",
                playerPositions: playerPositions,
                arenaData: array,
                upperLeftCornerLatitude: this.upperLeftCorner.latitude,
                upperLeftCornerLongitude: this.upperLeftCorner.longitude,
                lowerRightCornerLatitude: this.lowerRightCorner.latitude,
                lowerRightCornerLongitude: this.lowerRightCorner.longitude,
                gridUnitSize: this.gridUnitSize,
                ownId: id
            }
            toSend = JSON.stringify(toSend);
            player.ws.send(toSend);
        }
    }

    addPlayer(name, id, ws, color, x = -1, y = -1) {
        console.log(`Player with name ${name} and id ${id} is added to arena ${this.name}`);
        this.players.set(id, new Player(name, id, ws, this, color, x, y));
    }

    async removePlayer(id) {
        if (this.players.has(id)) {
            console.log(`Removing player with id ${id}`);
            await this.players.get(id).removeSelf();
            this.players.delete(id);
        }
    }

    async updatePosition(playerID, newLocation) {
        var player = await this.players.get(playerID);
        player.updatePosition(newLocation);
    }

    isOnGrid(gridCoords) {
        return new Promise(resolve => {
            resolve(0 <= gridCoords.x && gridCoords.x < this.gridSize.x &&
                0 <= gridCoords.y && gridCoords.y < this.gridSize.y);
        });
    }


    setAsTail(gridCoords, player) {
        console.log(`player ${player.id} tails ${gridCoords.x} ${gridCoords.y}`);
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].owner != player.id) {
                if (this.fields[gridCoords.x][gridCoords.y].isTail) {
                    previousPlayerID = this.fields[gridCoords.x][gridCoords.y];
                    previousPlayer = players[previousPlayerID];
                    previousPlayer.cutTail();
                }

                this.fields[gridCoords.x][gridCoords.y].owner = player.id;
                this.fields[gridCoords.x][gridCoords.y].isTail = true;
            }
        }
    }

    setAsOwner(gridCoords, player) {
        console.log(`player ${player.id} owns ${gridCoords.x} ${gridCoords.y}`);
        if (this.isOnGrid(gridCoords)) {
            console.log("kkkkk");
            if (this.fields[gridCoords.x][gridCoords.y].owner != player.id) {
                if (this.fields[gridCoords.x][gridCoords.y].isTail) {
                    previousPlayerID = this.fields[gridCoords.x][gridCoords.y];
                    previousPlayer = players[previousPlayerID];
                    previousPlayer.cutTail();
                }
            }
            this.fields[gridCoords.x][gridCoords.y].owner = player.id;
            this.fields[gridCoords.x][gridCoords.y].isTail = false;
        }
    }

    setAsEmpty(gridCoords) {
        if (this.isOnGrid(gridCoords)) {
            this.fields[gridCoords.x][gridCoords.y].owner = "none";
            this.fields[gridCoords.x][gridCoords.y].isTail = false;
        }
    }

    ownerOf(gridCoords) {
        return new Promise(resolve => {
            if (this.isOnGrid(gridCoords)) {
                resolve(this.fields[gridCoords.x][gridCoords.y].owner);
            }
            resolve(-1);
        });
    }
}


module.exports = {
    Arena, Player, Point, MapPoint
}