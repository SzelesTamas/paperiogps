class MapPoint {
    constructor(latitude, longitude) {
        this.latitude = latitude;
        this.longitude = longitude;
    }

    "-"(a, b) {
        return new MapPoint(a.latitude - b.latitude, a.longitude - b.longitude);
    }
}

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    manhattanDistance(other) {
        return new Promise(resolve => {
            resolve(Math.abs(this.x - other.x) + Math.abs(this.y - other.y));
        });
    }
}

class Field {
    constructor(owner = "none", tailOwner = "none") {
        this.owner = owner;
        this.tailOwner = tailOwner;
    }
}

class Player {
    constructor(name, id, ws, arena, color, x = -1, y = -1) {
        this.name = name;
        this.id = id;
        this.ws = ws;
        this.gridPosition = new Point(x, y);
        this.arena = arena;
        this.activTail = []; // array of point objects
        this.color = color;
        this.position = new MapPoint(-1, -1);
        this.hasBase = false;
    }

    isOutOfArenaGrid(gridCoords) {
        return new Promise(resolve => {
            var out = (
                gridCoords.x < 0 || gridCoords.y < 0 ||
                gridCoords.x >= this.arena.gridSize.x ||
                gridCoords.y >= this.arena.gridSize.y
            )
            resolve(out);
        });
    }

    cutTail() {
        console.log("cutTail is not implemented yet");
    }

    outOfArena() {
        console.log("outOfArena is not implemented yet");
    }

    async fillArea() {
        // find the boundary box of our area
        // fill this area
        // the leftout are is what is additional area
        console.log("filling area");
        let curr;

        if (this.activTail.length == 0) {
            console.log("no tail");
            return;
        }

        let upperLeft = new Point(1000000000, 1000000000);
        let lowerRight = new Point(-1, -1);

        for (let i = 0; i < this.activTail.length; i++) {
            upperLeft.x = Math.min(upperLeft.x, this.activTail[i].x);
            upperLeft.y = Math.min(upperLeft.y, this.activTail[i].y);
            lowerRight.x = Math.max(lowerRight.x, this.activTail[i].x);
            lowerRight.y = Math.max(lowerRight.y, this.activTail[i].y);
        }

        let stack = [];
        for (let i = upperLeft.x; i <= lowerRight.x; i++) {
            stack.push(new Point(i, upperLeft.y));
            stack.push(new Point(i, lowerRight.y));
        }
        for (let i = upperLeft.y; i <= lowerRight.y; i++) {
            stack.push(new Point(upperLeft.x, i));
            stack.push(new Point(lowerRight.x, i));
        }

        let visited = [];
        for (let i = upperLeft.x; i <= lowerRight.x; i++) {
            let temp = [];
            for (let j = upperLeft.y; j <= lowerRight.y; j++) {
                temp.push(false);
            }
            visited.push(temp);
        }

        let dirX = [0, 0, 1, -1];
        let dirY = [1, -1, 0, 0];

        while (stack.length > 0) {
            curr = stack[stack.length - 1];
            stack.pop();
            if (curr.x < upperLeft.x || curr.y < upperLeft.y || curr.x > lowerRight.x || curr.y > lowerRight.y) continue;

            if (visited[curr.x - upperLeft.x][curr.y - upperLeft.y] == true) continue;
            let owner = await this.arena.ownerOf(curr);
            if (owner == this.id) continue;
            owner = await this.arena.tailerOf(curr);
            if (owner == this.id) continue;

            visited[curr.x - upperLeft.x][curr.y - upperLeft.y] = true;
            for (let i = 0; i < 4; i++) {
                stack.push(new Point(curr.x + dirX[i], curr.y + dirY[i]));
            }
        }

        for (let i = upperLeft.x; i <= lowerRight.x; i++) {
            for (let j = upperLeft.y; j <= lowerRight.y; j++) {
                if (visited[i - upperLeft.x][j - upperLeft.y] === false) {
                    this.arena.setAsOwner(new Point(i, j), this);
                }
            }
        }

    }

    async addToTail(gridCoords) {
        this.activTail.push(gridCoords);
        this.arena.setAsTail(gridCoords, this);
    }

    // credit: https://www.redblobgames.com/grids/line-drawing.html
    async fillBetween(prevPos, currPos) {
        if (currPos.x == prevPos.x && currPos.y == prevPos.y) return;
        let dx = currPos.x - prevPos.x, dy = currPos.y - prevPos.y;
        let nx = Math.abs(dx), ny = Math.abs(dy);
        let sign_x = dx > 0 ? 1 : -1, sign_y = dy > 0 ? 1 : -1;

        let p = new Point(prevPos.x, prevPos.y);
        for (let ix = 0, iy = 0; ix < nx || iy < ny;) {
            if ((0.5 + ix) / nx < (0.5 + iy) / ny) {
                // next step is horizontal
                p.x += sign_x;
                ix++;
            } else {
                // next step is vertical
                p.y += sign_y;
                iy++;
            }
            await this.processPosition(new Point(p.x, p.y));
        }
    }

    async processPosition(gridCoords) {
        // is on own territory

        let owner = await this.arena.ownerOf(gridCoords);
        if (owner == this.id) {
            await this.fillArea();
            this.activTail = [];
        }
        else {
            await this.addToTail(gridCoords);
        }
    }

    async updatePosition(newLocation) {
        this.position.latitude = newLocation.latitude;
        this.position.longitude = newLocation.longitude;
        let gridCoords = await this.arena.convertToArenaGrid(newLocation);
        console.log(gridCoords);
        // out of arena
        if (await this.isOutOfArenaGrid(gridCoords) === true) {
            this.outOfArena();
        }
        else {
            let prevPos = this.gridPosition;
            this.gridPosition = gridCoords;
            let currPos = this.gridPosition;
            if (this.hasBase === false) {
                this.arena.setAsOwner(this.gridPosition, this);
                this.hasBase = true;
                return;
            }
            this.fillBetween(prevPos, currPos);
        }
    }

    // This is a very bruteforce method
    async removeSelf() {
        for (var i = 0; i < this.arena.gridSize.x; i++) {
            for (var j = 0; j < this.arena.gridSize.y; j++) {
                var owner = await this.arena.ownerOf(new Point(i, j));
                if (owner == this.id) {
                    this.arena.setAsEmpty(new Point(i, j));
                }
            }
        }
    }
}


class Arena {
    constructor(_name, _upperLeftCorner, _lowerRightCorner, _latitudeGridUnitCount) {
        this.players = new Map(); // playerid player map
        this.name = _name;
        this.fields = [];
        this.upperLeftCorner = new MapPoint(_upperLeftCorner.latitude, _upperLeftCorner.longitude);
        this.lowerRightCorner = new MapPoint(_lowerRightCorner.latitude, _lowerRightCorner.longitude);
        console.log("name ", _name);
        console.log(this.upperLeftCorner);
        this.sizeOnMap = new MapPoint(
            Math.abs(_lowerRightCorner.latitude - _upperLeftCorner.latitude),
            Math.abs(_lowerRightCorner.longitude - _upperLeftCorner.longitude));
        // because we want square units it's enough to have the count of units on only 1 axis
        // size of 1 grid unit in latitude and longitude
        // this may cause problems later, but I view latitude and longitue directly proportional
        this.gridSize = {
            x: _latitudeGridUnitCount,
            y: Math.floor(this.sizeOnMap.longitude / this.sizeOnMap.latitude * _latitudeGridUnitCount)
        };
        console.log(`This is the gridsize`);
        console.log(this.gridSize);
        this.gridUnitSize = this.sizeOnMap.latitude / this.gridSize.x;


        for (var i = 0; i < this.gridSize.x; i++) {
            var l = [];
            for (var j = 0; j < this.gridSize.y; j++) {
                l.push(new Field());
            }
            this.fields.push(l);
        }

        setInterval(() => { this.sendDataToPlayers(); }, 2000);
    }

    convertToArenaGrid(pointOnMap) {
        return new Promise(resolve => {
            if (pointOnMap.latitude > this.upperLeftCorner.latitude ||
                pointOnMap.latitude < this.lowerRightCorner.latitude ||
                pointOnMap.longitude < this.upperLeftCorner.longitude ||
                pointOnMap.longitude > this.lowerRightCorner.longitude) {

                // if it is outside the arena
                resolve(new Point(-1, -1));
            }
            else {
                var dif = new MapPoint(
                    this.upperLeftCorner.latitude - pointOnMap.latitude,
                    pointOnMap.longitude - this.upperLeftCorner.longitude);
                resolve(new Point(
                    Math.floor(dif.latitude / this.gridUnitSize),
                    Math.floor(dif.longitude / this.gridUnitSize)
                ));
            }
        });
    }

    // you could implement a more optimised version which only sends the changes but that's for later
    async sendDataToPlayers() {
        var array = JSON.stringify(this.fields);
        if (this.upperLeftCorner === undefined) return;
        var playerPositions = [];

        for (let [id, player] of this.players) {
            playerPositions.push(JSON.stringify({
                id: id,
                latitude: player.position.latitude,
                longitude: player.position.longitude
            }));
        }
        playerPositions = JSON.stringify(playerPositions);


        for (let [id, player] of this.players) {
            let toSend = {
                type: "arenaData",
                playerPositions: playerPositions,
                arenaData: array,
                upperLeftCornerLatitude: this.upperLeftCorner.latitude,
                upperLeftCornerLongitude: this.upperLeftCorner.longitude,
                lowerRightCornerLatitude: this.lowerRightCorner.latitude,
                lowerRightCornerLongitude: this.lowerRightCorner.longitude,
                gridUnitSize: this.gridUnitSize,
                ownId: id
            }
            toSend = JSON.stringify(toSend);
            player.ws.send(toSend);
        }
    }

    addPlayer(name, id, ws, color, x = -1, y = -1) {
        console.log(`Player with name ${name} and id ${id} is added to arena ${this.name}`);
        this.players.set(id, new Player(name, id, ws, this, color, x, y));
    }

    async removePlayer(id) {
        if (this.players.has(id)) {
            console.log(`Removing player with id ${id}`);
            await this.players.get(id).removeSelf();
            this.players.delete(id);
        }
    }

    async updatePosition(playerID, newLocation) {
        var player = await this.players.get(playerID);
        if (player == undefined) return;
        player.updatePosition(newLocation);
    }

    async isOnGrid(gridCoords) {
        return new Promise(resolve => {
            resolve(0 <= gridCoords.x && gridCoords.x < this.gridSize.x &&
                0 <= gridCoords.y && gridCoords.y < this.gridSize.y);
        });
    }


    setAsTail(gridCoords, player) {
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].owner != player.id) {
                if (this.fields[gridCoords.x][gridCoords.y].tailOwner != "none") {
                    let previousPlayerID = this.fields[gridCoords.x][gridCoords.y];
                    let previousPlayer = this.players[previousPlayerID];
                    if (previousPlayer != undefined) {
                        previousPlayer.cutTail();
                    }
                }
                this.fields[gridCoords.x][gridCoords.y].tailOwner = player.id;
            }
        }
    }

    setAsOwner(gridCoords, player) {
        if (this.isOnGrid(gridCoords)) {
            if (this.fields[gridCoords.x][gridCoords.y].tailOwner != "none") {
                let previousPlayerID = this.fields[gridCoords.x][gridCoords.y].tailOwner;
                let previousPlayer = this.players[previousPlayerID];
                if (previousPlayer != undefined) {
                    previousPlayer.cutTail();
                }
            }
            this.fields[gridCoords.x][gridCoords.y].owner = player.id;
            this.fields[gridCoords.x][gridCoords.y].tailOwner = "none";
        }
    }

    setAsEmpty(gridCoords) {
        if (this.isOnGrid(gridCoords)) {
            this.fields[gridCoords.x][gridCoords.y].owner = "none";
            this.fields[gridCoords.x][gridCoords.y].tailOwner = "none";
        }
    }

    async ownerOf(gridCoords) {
        return new Promise(resolve => {
            if (this.isOnGrid(gridCoords)) {
                resolve(this.fields[gridCoords.x][gridCoords.y].owner);
            }
            resolve(-1);
        });
    }

    async tailerOf(gridCoords) {
        return new Promise(resolve => {
            if (this.isOnGrid(gridCoords)) {
                resolve(this.fields[gridCoords.x][gridCoords.y].tailOwner);
            }
            resolve(-1);
        });
    }
}


module.exports = {
    Arena, Player, Point, MapPoint
}